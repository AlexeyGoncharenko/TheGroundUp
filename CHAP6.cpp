// Демонстрация использования указателей.
// Указатель - переменная, которая хранит адреса памяти.
/// <NB!> С помощью указателя реализуется ОПЕРАЦИЯ НЕПРЯМОГО ДОСТУПА. ///

#include "main.h"

using namespace std;

int main(int argv, char *argc[])
{
	// установка параметров locale
	cout << "---info:\n";
	cout << "Default locale:\t" << setlocale(LC_ALL, NULL) << endl;
	cout << "Set locale:\t" << setlocale(LC_ALL, ".1251") << endl;
	cout << "---\n\n";
	// операция приведения типа при работе с указателями разного типа сомнительна
	{
		double xDbl, yDbl;
		int *pInt;

		xDbl = 123.45;
		pInt = (int *)&xDbl;	// не смторя на приведение типа (int*) указатель по прежнему ссылается на значение с плав.точкой, но компилятор считает, что он указывает на целочисленное значение
								// ПРАВИЛО: Базовый тип указателя определят как компиялтору будет использовать данные на которые он ссылается.
		
		yDbl = *pInt;			// incorrect value(мусор), из-за чего нарушается последующие вычисления связанные с этим указателем и переменной yDbl

		cout << "&(xDbl) = " << &xDbl << '\n';	// получение адреса переменной
		cout << "xDbl = " << xDbl << '\n';		// получение значения переменной

		cout << "pInt = " << pInt << '\n';	// получение адреса переменной
		cout << "*(pInt) = " << *pInt << '\n';	// получение значения переменной по адресу

		cout << "&(yDbl) = " << &yDbl << '\n';	// получение адреса переменной
		cout << "yDbl = " << yDbl << '\n';	// получение значения переменной
	}


	// обход (с помощью типа void) соответсвия базового типа с типом данных на которые, он ссылается в инструкции присваивания.	
	{
		long double dVar1 = 3.35L, dVar2;	// можно менять тип переменной, и при этом инструкция ниже не вызовет ошибки, это одна из потенциальных проблем использования указателей.
		void *pVoid = &(dVar1);	// указатель может ссылаться на "бог-знает-что", это применимо только для указателей типа void, для других выполнятся проверка <БАЗОВЫЙ ТИП УКАЗАТЕЛЯ = БАЗ.ТИПУ ПЕРЕМЕННОЙ НА КОТОРУЮ ОН ССЫЛАЕТСЯ>
		
		cout << "&dVar1 = " << &dVar1<< endl;
		cout << "dVar1 = " << dVar1<< endl;

		cout << "pVoid = " << pVoid << endl;

		dVar2 = *(reinterpret_cast<long double*>(pVoid));	// вот, так безопасно сначала получаем указатель, на что хотим, потом безопасно, объясняем компилятору, как использовать данные на которые ссылается указатель типа void
		cout << "*pVoid = " << dVar2<< endl;
	}

	// арифметические операции с указателями РАЗРЕШЕНЫ ТОЛЬКО: - + -- ++, СКЛАДЫВАТЬ УКАЗАТЕЛИ НЕЛЬЗЯ, А ВЫЧЕСТЬ ОДИН УКАЗАТЕЛЬ ИЗ ДРУГОГО МОЖНО, ЕСЛИ ОНИ ОБА ИМЕЮТ ОДИН И ТОТ ЖЕ БАЗОВЫЙ ТИП
	int iValue = 9;
	int *pInt = &iValue;
	*pInt++; // (*pInt)++ - в данном случае значение области памяти на которое ссылается pInt, будет измененно. 
			   // НО, так  *pInt++ - изменение не произойдет - поскольку приоритет операции инкремента (++) выше чем операции взятия по адресу (*). Сначала произойдет инкремет значения адреса, а потом произойдет обращение к значению по УЖЕ НОВОМУ адресу, значение ячейки никак не изменится.
	cout << "iValue = " << iValue << endl;


	int iArr[5] = {1,2,3,4,5};
	int *pArr = iArr;

	cout << "\n  состояние массива: ";
	for(int i = 0; i < sizeof(iArr)/sizeof(int); i++) cout << iArr[i];
	
	// modify values in array
	for(int i = 0; i < sizeof(iArr)/sizeof(int); i++) {
		// здесь эксперементируем, над приоритетами операторов ++ -- * ()  # (*pArr)++ 
		(*pArr)++; // использовали, поскольку приоритет оператора ++ выше, чем *
		// *pArr++ = i; // в данном случае первым выполняется оператор ++, а потом * и =, но поскольку ++ в постфиксной записи меняет операнд, после выполнения инсрукции, в инструкции фигурирует старое значение, на новое попадаем только на следующей итерации.
		// *++pArr = i; // выход за пределы определения массива => вызовет ошибку выполнения программы.
	}
	
	cout << "\nИзмененное состояние массива: ";
	for(int i = 0; i < sizeof(iArr)/sizeof(int); i++) 
		cout << iArr[i];
	cout << endl;

	// Разность указателей указывает сколько элементов БАЗОВОГО ТИПА расположенно между ними 
	// Разность указателей указывает сколько элементов БАЗОВОГО ТИПА расположенно между ними
	int *p1 = &iArr[0]; 
	int *p2 = &iArr[4]; 
	float diff = (p2 - p1);
	cout << "Разность указателей: количество эл-ов между адресом " << p1 << " и адресом " << p2 << " составляет " << diff << endl;

	// cout-инструкция, при выводе в неё адреса преобразует в формат адресации, применяемого для текущего процессора и среды выполнения 
	int *i, j[10];
	float *f, g[10];
	int x;
	i = j;
	f = g;
	cout << "\tINTEGER\t\tFLOAT\n";
	for(x = 0; x < 10; x++) {
		cout << '\t' << i + x << "\t" <<  f + x << '\n';
	}


	// СРАВНЕНИЕ УКАЗАТЕЛЕЙ.
	system("pause");
	return EXIT_SUCCESS;
}