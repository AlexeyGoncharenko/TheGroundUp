#include "main.h"
#include <ciso646>	//	здесь определенны СИНОНИМЫ к некоторым операторам 
					//	and (&&), bitand (&), and_eq (&=), or (||), bitor (|), or_eq (|=), xor (^), xor_eq (^=), not (!), not_eq (!=), compl (~)
using namespace std;

#define TOP_LEVEL_GOTO 1000000000000
#define TOP_LEVEL_MAGIC_VAL 10

int main(int argc, char* argv[])
{	
	char *ansToSetLocale = ::setlocale(LC_ALL, "rus"); // установка настроек окружения для русскоязычного ввода/вывода на cout/cin
	cout << "Set locale: " << ansToSetLocale << endl; 

	/// <место вызова функций, которые необходимо протестировать...> ///
	testGeneralCplusplusType();


	cout << "\n\n";
	cout << "Выполенены все заданые функции. Далее будет запущена игра \'Угадай магическое чило\'\n";
	system("pause");

	// Запускаем часть программы, в которой реализованна игра "Угадай магическое число
	// В игре генерируется псевдо-случайное число в диапазоне от 0..10, у пользователю представляется возможность угадать число с TOP_LEVEL_MAGIC_VAL/2 попыток (по умолнчанию 5 попыток).
	unsigned magic_num = 0U;
	unsigned option = 0;
	srand((unsigned int) time(NULL)); // инициализация начального значения для генератора псевдо-случайных чисел.
	do{
		system("cls"); // очистить экран от придыдущих сообщений
		cout << "1. Сгенерировать новое магическое число\n";
		cout << "2. Сыграть\n";
		cout << "3. Выход из программы\n";
		do {
			cout << "Введите соотвествующий пункт меню: ";
			cin >> option;
		} while(option < 1 || option > 3);
		switch(option) {
		case 1:
			magic_num = rand()%TOP_LEVEL_MAGIC_VAL; // магическое число генерируем в диапазоне от 0..TOP_LEVEL_MAGIC_VAL
			break;
		case 2:
			play(magic_num);
			break;
		case 3:
			cout << "До свидания!\n";
		}
	} while( option != 3);

	system("pause");
	return EXIT_SUCCESS;
}

// работа с базовыми типами данных C++
void testGeneralCplusplusType()
{
	cout << "Выполнение фунции testGeneralCplusplusType()\n";

	//	тестирование типа void. Функция с типом возвращаемого значения void ничего не может возвратить, а вот функция с типом возвращаемого значения void* может.
	{
		cout << "Тестирование типа void. Получение адреса с помощью функции возвращающей тип void*" << endl; 
		int *pInt, ival;
		void *pVoid = testVoidType();
		pInt = (int*)pVoid;	//	приведение типа 
		ival = *pInt;
		printf("Получили адрес 0x%X.\nДанные хранимые по этому адресу: %d\n", pVoid, ival);
		*pInt = 1001;	//	меняем содержимое выделенной памяти по адресу pInt (ПАМЯТЬ, БУКВАЛЬНО ПОСЛЕ ВЫПОЛНЕНИЯ ОДНОЙ ПРОГРАММНОЙ ИНСТРУКЦИЮ ПАМЯТЬ НА КОТОРУЮ УКАЗЫВАЕТ pInt СТАНИВИТЬСЯ НЕ ВАЛИДНОЙ), переменная ival получит "мусор"
		printf("Изменяем содержимое памяти находившееся по адресу 0x%X: с %d на 1001\n", pVoid, ival);		
		ival = *pInt;	//	проверяем состояние памяти...
		printf("Содержимое памяти 0x%X после изменения(память по указаному адресу уже невалидная): %d\n", pVoid, ival);
		system("Pause");	//	Значение аргумента-строки регистронезависимое. (# system("PaUse") system("pAUSe") system("pause"))
	}
	//
	



	cout << "Использование побитовых операторов и макросов препроцессора <ciso646>\n"; 
	// наглядное использования макросов препроцессора как альтернативный инструмент для побитовых, логических операций.
	{
		int a = 5;
		int bitand ra = a; // bitand позволяет использовать себя для выполнения побитового оператора И, так и оператора взятия адреса & и даже при задании ссылочных типов.
		cout << "\nЗначение int-переменной a = " << a << " (address " << &a << ")\n" << "Значение ссылочной int-переменной ra = " << ra << " (address " << &ra << ")\n";
		
		bool b1 = true, b2 = false;
		cout << "Значения bool-переменных b1 = " << b1 << " b2 = " << b2 << '\n';
		cout << "Результат операции (b1 and b2) = " << (b1 and b2) << '\n';
		if(b1 and b2) ;	//	пример пустого тела условного оператора if, ; - символ обозначающий конец программной инструкции ОБЯЗАТЕЛЕН!
		
		cout << "\nОбмен значениями без использования буфера. Операция осуществима с использованием побитовой операции XOR\n";
		int x = 0x0001,
			y = 0x0010;
		cout << "Значение переменных x = " << x << " y = " << y << '\n';
		cout << "Результат операции x = x xor y = " << (x = x xor y) << endl;
		cout << "Результат операции y = y xor x = " << (y = y xor x) << endl;
		cout << "Результат операции x = x xor y = " << (x = x xor y) << endl;
	}
	system("pause");

	/*	
	несколько слов о операторе ","  - этот оператор позволяет задавать списки объявления однотипных переменных, 
	или объявления списка формальных параметров функции. Также используется в выражениях: 
	значение оператора "," является значение правого оператора (см.пример)
	*/
	{
		cout << "Оператор ',' кроме объявления списков переменных, формальных параметров также используется в выражениях."
			 << "Значение ',', является значение правого оператора\n";
		int x = 1, y = 5, result = 0;
		cout << "Значение int-переменных x = " << x << " y = " << y << " result = " << result << '\n';
		cout << "Результат выполнения выражения result = (y = 1, y + 1) = " << (result = (y = 1, y + 1)) << '\n';
		system("pause");
	}

	
	unsigned size = sizeof(true); // размер ключевых слов(они же булевы константы) равен 1 байт. True,false - единственные значения, которые может принимать переменная типа bool
	void *pVoid = (void*)0;
	size = sizeof(pVoid);	// выдаст размер адреса = 4 байта
	int iarr[5] = {0};
	size = sizeof(iarr);	// но здесь выдаст истинный размер массива, который равен 20 байт, хотя на входе подается имя массива, которое представляет собой константный указатель... страно всё это...
	char *string = "Simple ' \' ? \? x00A";
	size = sizeof(string);	// выдаст размер адреса = 4 байта

	/// модификаторы можно записывать до или после имени типа.
	unsigned short int usi1 = 0;
	short unsigned int usi2 = 0;
	// проверка и иллюстрация как устроенно предаставление диапазона значений для базовых типов данных, так называемый КРУГ ДИАПАЗОНА ПРЕДСТАВЛЕНИЯ
	usi1 = 65538;
	usi2 = 65539;
	short signed si1 = 0;
	si1 = 60000;

	int i = 5; 
	char c = 2;
	float f = 3.0f;
	double d = 2.0;
	double result = (i/(double)c) + (f*d) + (f+i); // в одном флаконе преобразование типов в выражениях, приведение типов, порядок выполнения действий(приоритет операторов)
	
	// тестируем тип данных bool
	bool a(false), /*b = "str", b = 'w'*/ b = 2.9; /*	с помощью оператора присваивания переменной типа bool можно присваивать различные(строки, символы, целочисленные значения, веществ.значения) допустимые значения, компилятор любое значение не равное нулю преобразует в true, а ноль в false
														но при присваивании значения bool-переменной с помощью оператора cin, любое значение(строка, символ, целочил.зн, веществ.зн) превышающее 1 будет интерпретироваться как false
													*/		
	cin >> a >> b;
	cout << "a = " << a << " b = " << b << endl;
	cout << "Result operation a&&b = " << (a&&b) << endl;
	cout << "Result operation a||b = " << (a||b) << endl;
	cout << "Result operation XOR(a,b) = " << ((a||b)&&(!(a&&b))) << endl;
	clear_iostream();
	system("pause");
}
void play(unsigned int magic_number)
{
	unsigned guess_num = 0U;
	cout << "i: Угадай  магическое число от 0.."<< TOP_LEVEL_MAGIC_VAL << '\n';
	cout << "i: Количество попыток = " << TOP_LEVEL_MAGIC_VAL/2 << '\n';
	int iterVal;
	for(iterVal = 0; iterVal < TOP_LEVEL_MAGIC_VAL/2 ; iterVal++) { // количество попыток = TOP_LEVEL_MAGIC_VAL/2
		cin >> guess_num;
		if(guess_num == magic_number) {
			cout << "Вы угадали магическое число\n";
			break;	
		}
		else {
			cout << "Вы не угадали магическое число\n";
			if(guess_num > magic_number)
				cout << "Ваше число больше магического числа\n";
			else
				cout << "Ваше число меньше магического числа\n";
		}
	}
	if(iterVal == TOP_LEVEL_MAGIC_VAL/2)
		cout << "Вы использовали все шансы угадать число.\n" 
		<< "Попытайтесь снова...\n";
	system("pause");
}
//	Вложенные if инструкции
void embbeded_if()
{
	int magic_number = 0;
	int guess_number = 0;
	srand((unsigned int)time(NULL)); // генерация начального значения для генератора псевдослучайных чисел 
	magic_number = rand()%TOP_LEVEL_MAGIC_VAL; // генерируем псевдослучайное число в диапазоне 0..TOP_LEVEL_MAGIC_VAL
	cout << "Угадайте magic_number. Введите число в диапазоне 0..100: "; cin >> guess_number;
	if(guess_number == magic_number)
	{
		// составной оператор - блок
		cout << "\tВы угадали!\n\a";
	}
	else
	{
		if(guess_number > magic_number)
			cout << "Ваше число больше magic_number (" << magic_number << ")\n";
		else
			cout << "Ваше число меньше magic_number (" << magic_number << ")\n";
	}
}
//	Цикл for
void for_instruction()
{
	// kbhit() - функция возвращает TRUE, если одна из клавиш клавиатуры была нажата, в противном случае FALSE
	// INT_MAX - максимально допустимое значение для типа данных signed integer
	cout << "Программа вычисляет квадрат.корень из последовательности 1..INT_MAX, для остановки вычислений нажмите любую клавишу" << '\n';
	system("pause");
	for(int start_value = 1; !_kbhit() && start_value <= INT_MAX; start_value++)
	{
		cout << "sqrt(" << start_value << ") = " << sqrt((double)start_value) << '\n';
	}

	// пример цикла временнОй задержки
	int iter, max_value = 1000;
	for(iter = 0; iter < max_value; iter++) ;
}
//	switch - инструкция многонаправленного ветвления
void switch_instuction()
{
	int choice = 0;
	for(;;)
	{
		cout << "?: Справка по программным инструкциям\n";
		cout << "\t1. for\n";
		cout << "\t2. if\n";
		cout << "\t3. switch\n";
		cout << "\t4. exit\n";
		
		cout << "   Введите номер инструкции (1-3): "; cin >> choice; clear_iostream();

		switch(choice) { // switch(выражение) т.е. элемент выражение м.б. и выражение+1, выражение%5, выражение > 10, выражение & 5. Важно, чтобы элемент ВЫРАЖЕНИЕ давал при вычислении ЦЕЛОЧИСЛЕННОЕ или  СИМВОЛЬНОЕ значение.
		case 1:
			cout << "----------------------------------------" << '\n';
			cout << "for - это самый универсальный цикл в С++" << '\n';
			cout << "----------------------------------------" << '\n';
			break;
		case 2:
			cout << "----------------------------------------" << '\n';
			cout << "if - это инструкция условного ветвления" << '\n';
			cout << "----------------------------------------" << '\n';
			break;
		case 3:
			cout << "----------------------------------------" << '\n';
			cout << "switch - это инструкция многонаправленного ветвления" << '\n';
			cout << "----------------------------------------" << '\n';
			break;
		case 4:
			return;
			break;
		default:
			cout << "Номер введенной инструкции не соотвествует ни одной из указанных в списке доступных..." << '\n';
		}
		system("pause");
		system("cls");
	}

}
//	switch - вложенная инструкция многонаправленного ветвления
void embbeded_switch_instuction()
{
	// case-константы внешних и внутрених switch-инструкций могут совпадать.
	char chVal_1 = 'A';
	char chVal_2 = 'C';
	switch(chVal_1){
	case 'A':
		cout << "Это константа А - часть внешней инструкции switch\n";
		switch(chVal_2){
		case 'A':
			cout << "Это константа А - часть внутренней инструкции switch\n";
			break;
		case 'B':
			cout << "Это константа B - часть внутренней инструкции switch\n";
			break;
		default:
			cout << "Default константа - часть внутренней инструкции switch\n";
		}
		break;
	case 'B':
		cout << "Это константа B - часть внешней инструкции switch\n";
		break;
	default:
			cout << "Default константа - часть внешней инструкции switch\n";
	}
}
//	Цикл while
void while_instuction()
{
	unsigned char ch = 32;
	// unsigned char ch = -1; приведет к тому, что переменная переменная получит значение 255. РАБОТАЕТ ТАК НАЗЫВАЕМЫЙ КРУГ ЗНАЧЕНИЙ(Диапазон представления значений типов данных) 0..255
	// выводим на печать символы с кодом начиная с 32 и заканчивая 255
	cout<<'\n';
	while(ch) { // когда ch примет значение > 255, то она обнулиться (прийдет к началу круга значений, сделает полный проход)
		cout << ch << ' ';
		++ch;
	}
	cout << "\n\n";
}
//	Алгоритм нахождения простых чисел из заданного диапазона
void find_prime_number(int start_position, int end_position)
{
	if(start_position < end_position) {
		int i = 0, j = 0;
		for(i = start_position; i < end_position; i++) { // деление на единицу не учитываем, поскольку ищем простое число. 
			for(j = start_position; j <= (i/j); j++) {
				// Если число имеет множитель, значит, оно не простое.
				if(!(i%j)) break; // небольшая хитрость работы оператратора ! или not - данный оператор любое ненулевое число превратит в НОЛЬ # int ival = not(123), в результате переменная ival получить значение НОЛЬ
			}
			if(j > (i/j))
				cout << i << " - простое число\n";
		}
	}
	else
		cout << "Функции переданны некорректные параметры\n\a";
}
//	Пример использования инструкции GOTO
void goto_instruction()
{
	/*	приведена возможная ситуация использования инструкции goto (выход из глубоковложенных циклов), 
		без неё с использованием break необходимо было бы использовать ещё допольнительные проверки 
	*/
	unsigned int iVal = 1;
	for(int i = 1; i < TOP_LEVEL_GOTO; i++) {
		for(int j = 1; j < TOP_LEVEL_GOTO; j++) {
			while(iVal) {
				iVal += j;
				if(iVal == 100) goto stop;
			}
		}
	}
stop:
	cout << "Ошибка в программе\n\a"; 
}
//	очистка потока ввода/вывод
void clear_iostream()
{
	cin.ignore(numeric_limits<streamsize>::max(), '\n');
	cin.clear();
}
//	тестирование типа void
void* testVoidType(void)
{
	//	функция объявленная с типом возвращаемого значения void не может возврващать значение, и в этом случае оператор return должен указываться пустым.
	//	Но иначе обстоят дела с типом возвращаемого значения void*. Мы можем вернуть значение(либо просто формируем адрес, либо создаем переменную и передаем адрес выделенной под неё памяти)
	//	во вызывающую среду. Причем это значение безболезненно преобразуется в указатели любого допустимого типа данных С++.
	int iNewMem = 5;	//	создаем локальную именнованую область памяти
	void *pVoid = (void*)&iNewMem;	//	Запоминаем адрес, и передаем его в вызывающую среду. Но при этом, не понятно одно. Не статические ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ создаются при вызове функции, и разрушаются при выходе из неё - ПАМЯТЬ ВЫДЕЛЕНЕННАЯ ПОД ЭТИ ПЕРЕМЕННЫЕ ОСВОБОЖДАЕТСЯ!!!
									//	Таким образом, получается, что использовать эту выделенную память по ссылке дальше являеся крайне сомнительным и 
									//	опасным действием(как видно в результате, в вызывающей функции, которая получила адрес этой области, значение не сохраняется, буквально после изменения значения в этой области, через две инструкции, эта область меняет присвоенное значение на другое) 
									//	Либо компилятор сохраняет выделенную локальную память валидной, даже после выхода из лок.области, где она была выделенна,
									//	но только, в том случае, если при выходе из этой локальной области, была переданна ссылка/указатель на эту область.
	return pVoid;
}
